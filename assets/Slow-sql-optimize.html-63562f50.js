import{_ as d,W as a,X as i,a1 as e,Y as t}from"./framework-817d905c.js";const s={},n=e(`<h2 id="开启并查找慢查询日志" tabindex="-1"><a class="header-anchor" href="#开启并查找慢查询日志" aria-hidden="true">#</a> 开启并查找慢查询日志</h2><p>背景：MySQL单节点负载过高，先不要盲目增加从节点来提升负载能力，应先进行SQL调优，保证单机性能的优化达到一个优秀的地步</p><h3 id="一、先确定是否开启慢查询日志" tabindex="-1"><a class="header-anchor" href="#一、先确定是否开启慢查询日志" aria-hidden="true">#</a> 一、先确定是否开启慢查询日志</h3><p>如果没有开启，则先开启慢查询日志记录</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> ‘slow_query_log’<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;slow_query_log&#39;;
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | ON    |
+----------------+-------+
1 row in set (0.01 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二、查看慢查询时间阈值" tabindex="-1"><a class="header-anchor" href="#二、查看慢查询时间阈值" aria-hidden="true">#</a> 二、查看慢查询时间阈值</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;long_query_time&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;long_query_time&#39;;
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 1.000000 |
+-----------------+----------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="三、查看慢查询日志存储位置" tabindex="-1"><a class="header-anchor" href="#三、查看慢查询日志存储位置" aria-hidden="true">#</a> 三、查看慢查询日志存储位置</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">&#39;slow_query_log_file&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;slow_query_log_file&#39;;
+---------------------+--------------------------+
| Variable_name       | Value                    |
+---------------------+--------------------------+
| slow_query_log_file | /data/xxx/logs/slow.log |
+---------------------+--------------------------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">提示</p><p>以上内容都可以通过<code>my.cnf</code>或者<code>set global</code>命令修改</p></div><h3 id="四、查询慢查询日志-取出其中的sql进行分析优化" tabindex="-1"><a class="header-anchor" href="#四、查询慢查询日志-取出其中的sql进行分析优化" aria-hidden="true">#</a> 四、查询慢查询日志，取出其中的SQL进行分析优化</h3><p><code>mysqldumpslow</code>是导出并分析慢SQL的工具，下面说一下基本参数</p><ul><li><p>-s : 排序类型</p><ul><li>t, 按查询时间或者平均查询时间排序</li><li>l, 按锁表时间排序</li><li>r, 按返回数据条目数进行排序</li><li>c, 按使用次数总数排序</li></ul></li><li><p>-t : TopN 返回排序前N条数据</p></li></ul><p>例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> mysqldumpslow <span class="token parameter variable">-s</span> c <span class="token parameter variable">-t</span> <span class="token number">10</span> ./slow.log <span class="token operator">&gt;</span> .slow-20231122.log  <span class="token comment"># 取出使用最多的10条慢查询</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,18),l=t("p",{SQL:""},"EXPLAIN",-1),r=e(`<h2 id="慢查询分析优化" tabindex="-1"><a class="header-anchor" href="#慢查询分析优化" aria-hidden="true">#</a> 慢查询分析优化</h2><h3 id="explain-结果解释" tabindex="-1"><a class="header-anchor" href="#explain-结果解释" aria-hidden="true">#</a> EXPLAIN 结果解释</h3><p>使用<code>Explain</code>关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>通过<code>Explain</code>，我们可以分析出以下结果：</p><ul><li>表的读取顺序</li><li>数据读取操作的类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>没张表有多少行被优化器查询</li></ul><p>EXPLAIN + SQL语句</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行计划包含的信息如下：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filterd</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t1</td><td></td><td>range</td><td>uniq_member_class_stage,idx_f_enroll_time</td><td>idx_f_enroll_time</td><td>6</td><td></td><td>50806</td><td>100.00</td><td>Using index condition; Using MRR; Using temporary; Using filesort</td></tr><tr><td>1</td><td>SIMPLE</td><td>t2</td><td></td><td>ref</td><td>idx_member_id</td><td>idx_member_id</td><td>9</td><td>tb_prod.t1.f_member_id</td><td>2</td><td>100.00</td><td>Using where; Using join buffer (Batched Key Access)</td></tr><tr><td>1</td><td>SIMPLE</td><td>t3</td><td></td><td>ref</td><td>idx_member_id</td><td>idx_member_id</td><td>9</td><td>tb_prod.t1.f_member_id</td><td>2</td><td>100.00</td><td>Using where; Using join buffer (Batched Key Access)</td></tr></tbody></table><p>字段含义：</p><h3 id="_1-id" tabindex="-1"><a class="header-anchor" href="#_1-id" aria-hidden="true">#</a> 1. id</h3><p>select 查询的序号，包含一串数字，表示查询中执行select字句或操作表的顺序</p><p>id的结果共有3种情况：</p><ul><li>id相同，执行顺序由上至下</li><li>id<mark>不同</mark>，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id有相同的也有不同的，同时存在时，id相同认为是一组，从上往下顺序执行，id不同的，值越大优先级越高</li></ul><h3 id="_2-selec-type" tabindex="-1"><a class="header-anchor" href="#_2-selec-type" aria-hidden="true">#</a> 2. selec_type</h3><p>常见和常用的值有以下几种：</p><table><thead><tr><th>id</th><th>select_type</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td><code>简单的select查询</code>，查询中<code>不包含子查询或者union</code></td></tr><tr><td>2</td><td>PRIMARY</td><td>查询中若<code>包含任何复杂的</code>子部分，<code>最外层查询则被标记为PRIMARY</code></td></tr><tr><td>3</td><td>SUBQUERY</td><td><code>在SELECT或者WHERE列表中包含了子查询</code></td></tr><tr><td>4</td><td>DERIVED</td><td>在FROM列表中包含的<code>子查询被标记为DERIVED</code>（衍生），MySQL会递归执行把这些子查询放在<code>临时表</code>中</td></tr><tr><td>5</td><td>UNION</td><td>如果第二个SELECT出现在UNION之后，则标记为UNION，如果UNION出现在FROM子句的子查询中，标记为DERVIED</td></tr><tr><td>6</td><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><h3 id="_3-table" tabindex="-1"><a class="header-anchor" href="#_3-table" aria-hidden="true">#</a> 3. table</h3><p>指的就是当前执行的表</p><h3 id="_4-type" tabindex="-1"><a class="header-anchor" href="#_4-type" aria-hidden="true">#</a> 4. type</h3><p>type所显示的是查询使用了哪种类型，type包含的类型包括以下几种：</p><blockquote><p>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</p></blockquote><p>依次从左至右表示性能高低</p><p>一般来说，得保证查询至少达到range级别，最好能达到ref</p><ul><li><code>system</code>表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略</li><li><code>const</code>表示通过索引一次就找打了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如果将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li><li><code>eq_ref</code>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li><li><code>ref</code>非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以应该属于查找和扫描的混合体</li><li><code>range</code>只检索给定范围的行，使用一个索引来选择行，Key列显示使用了哪个索引，一般就是在where条件中出现between、&gt;、&lt;、in等的查询，这种范围扫描索引比全表扫描要好，它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li><li><code>index</code>Full Index Scan，Index与All区别为index类型只遍历索引树。通常比ALL快，因为索引未见通常比数据文件小。（也就是说，虽然all和index都是读全表，但是index是从索引中读取的，而all是从硬盘读取的）</li><li><code>all</code>Full Table Scan 将便利全表以找到匹配的行</li></ul><h3 id="_5-possible-keys-和-key" tabindex="-1"><a class="header-anchor" href="#_5-possible-keys-和-key" aria-hidden="true">#</a> 5. possible_keys 和 key</h3><p><code>possible_keys</code>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。</p><p><code>key</code>实际使用的索引，如果为NULL，则没有使用索引（可能原因包括没有建立索引或索引失效）。若查询中使用了<code>覆盖索引</code>（select后要查询的字段刚好和创建的索引字段完全相同，无需回表），则该索引<strong>仅出现在key列表中</strong>。</p><h3 id="_6-key-len" tabindex="-1"><a class="header-anchor" href="#_6-key-len" aria-hidden="true">#</a> 6. key_len</h3><p>表示索引中使用的字节数，通过该列计算查询中使用的索引长度，在<code>不损失精确性的情况下，长度越短越好</code>。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，而不是通过表内检索出的。</p><h3 id="_7-ref" tabindex="-1"><a class="header-anchor" href="#_7-ref" aria-hidden="true">#</a> 7. ref</h3><p>显示索引的哪一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。</p><h3 id="_8-rows" tabindex="-1"><a class="header-anchor" href="#_8-rows" aria-hidden="true">#</a> 8. rows</h3><p>根据表信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，越少越好</p><h3 id="_9-extra" tabindex="-1"><a class="header-anchor" href="#_9-extra" aria-hidden="true">#</a> 9. Extra</h3><p><code>包含不适合在其它列中显示但十分重要的额外信息</code></p><h4 id="_9-1-using-filesort-九死一生" tabindex="-1"><a class="header-anchor" href="#_9-1-using-filesort-九死一生" aria-hidden="true">#</a> 9.1. Using filesort（九死一生）</h4><p>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。</p><h4 id="_9-2-using-temporary-十死无生" tabindex="-1"><a class="header-anchor" href="#_9-2-using-temporary-十死无生" aria-hidden="true">#</a> 9.2. Using temporary（十死无生）</h4><p>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</p><h4 id="_9-3-using-index-发财了" tabindex="-1"><a class="header-anchor" href="#_9-3-using-index-发财了" aria-hidden="true">#</a> 9.3. Using index（发财了）</h4><p>表示相应的select操作中使用了覆盖索引（Covering Index），避免了回表访问数据行，效率不错。如果同时出现了using where，表明索引被用来执行索引键值的查找，其它过滤条件需要回表查询；如果没有同时出现using where，表明索引用来读取而非执行查找动作。如果见到Using index condition，表示过滤条件在索引中就可以完成，无需回表。</p><div class="hint-container info"><p class="hint-container-title">什么是覆盖索引？</p><p>总的来说就是所有查询动作，条件过滤，排序等都无需回表，直接在索引树上就可以完成。</p><p>理解方式一：select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<code>查询列要被建立的索引覆盖</code>。</p><p>理解方式二：索引的高效找到行的一个办法，但是一般数据库也能使用索引找到一个列的数据，因此不必读取整个行。毕竟索引叶子结点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖）满足查询结果的数据就叫做覆盖索引。</p><p>注意：<br> 如果要使用覆盖索引，一定要注意select列表中只读取出需要的列，不可 select *，<br> 如果将所有字段一起做索引会导致索引文件过大，查询性能下降</p></div><h4 id="_9-4-using-where" tabindex="-1"><a class="header-anchor" href="#_9-4-using-where" aria-hidden="true">#</a> 9.4. Using where</h4><p>表明使用了where过滤，可以理解为回表了</p><h4 id="_9-5-using-join-buffer" tabindex="-1"><a class="header-anchor" href="#_9-5-using-join-buffer" aria-hidden="true">#</a> 9.5. Using join buffer</h4><p>表明在查询返回结果，使用了临时缓存，比如在查询的时候，多表Join或者子查询数据量太大，就会出现。通过将配置文件中的缓冲区的join buffer调大一些，可以降低出现频次，但是缓冲区过大也会引起查询慢问题。</p><h4 id="_9-6-impossible-where" tabindex="-1"><a class="header-anchor" href="#_9-6-impossible-where" aria-hidden="true">#</a> 9.6. impossible where</h4><p>where 字句的值<code>总是false</code>，不能用来获取任何数据</p><h4 id="_9-7-select-tables-optimized-away" tabindex="-1"><a class="header-anchor" href="#_9-7-select-tables-optimized-away" aria-hidden="true">#</a> 9.7. select tables optimized away</h4><p>在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作或者对于MyLSAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即将完成优化。</p><h4 id="_9-8-distinct" tabindex="-1"><a class="header-anchor" href="#_9-8-distinct" aria-hidden="true">#</a> 9.8. distinct</h4><p>优化distinct操作，在找到第一匹配的元组后即停止同样值的动作</p><p><strong>所谓优化慢查询，就是要解决执行器在执行过程中的不利因素，为SQL执行创造有利条件，以此来达到优化SQL的目的。</strong></p>`,54),o=[n,l,r];function c(h,p){return a(),i("div",null,o)}const b=d(s,[["render",c],["__file","Slow-sql-optimize.html.vue"]]);export{b as default};
